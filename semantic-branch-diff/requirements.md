# CM 3.0 — Semantic Config Pipeline

**Origin**: [824295 — CM Import: Reliable Diff Elimination](https://o9git.visualstudio.com/CoreDev/_workitems/edit/824295)

**About this document.** This is more prescriptive than a traditional requirements spec. The PM authored it with direct access to the codebase (via Claude Code), tracing the dependency chain from the original requirement through the code to the architectural conclusions. The intent is to collapse the usual PM-to-architect discovery round-trip — arriving at the conversation with the investigation already done, so the scope justification and the technical direction are in one place rather than split across a requirements handoff and a weeks-later architecture response. The companion [Analysis](analysis.md) and [Architecture Notes](architecture.md) documents carry the deeper codebase investigation and implementation detail, respectively.

---

## The Starting Requirement

> The core success metric for CM 2.0 is diff elimination: once a package is imported, those changes should no longer appear as diffs between the source and target branches. This doesn't work reliably, and it is the most critical problem with CM 2.0.
> 
> Git updates during CM package imports are not a source-branch-to-target-branch cherry-pick merge, but the result of TenantDB CRUD operations syncing to Git. This means the same logical entity state can produce textually different Git files due to different CRUD paths, different platform versions, or serialization variations.
> 
> All CM 2.0 branch-vs-branch diffs must be generated by deserializing Git file content into strongly typed objects and comparing them through the diff engine. Two files that represent the same logical entity state must be concluded as identical regardless of how they look in Git. Only entities that are semantically different should appear in the diff and be included in the package.

This requirement (ADO 824295) identified the problem and the direction. Codebase analysis deepened it significantly — surfacing dependencies that expand the scope from a diff fix to a pipeline redesign, and revealing that the new architecture solves most of CM 2.0's known problems. That's what makes this CM 3.0.

---

## The Problem

The current branch-vs-branch diff delegates comparison to the Git provider (ADO). This is a **textual diff** of serialized JSON files — the platform has no control over comparison semantics.

This creates three categories of false positives:

1. **Different CRUD paths**: The same entity serialized through different code paths (direct CRUD vs. package import vs. promotion) can produce textually different JSON files that are semantically identical. Property ordering, default value inclusion, whitespace, and null-vs-absent fields can all vary.

2. **Different platform versions**: An entity created on platform version X and the "same" entity created on version Y may serialize differently due to schema changes, new default values, or serialization logic updates.

3. **Different file structure across branches**: Base and delta are separate Git repos. A delta module points to a tag in its base module; during compilation, the two are merged by treating delta content as overrides on top of base. An entity's Git representation can change structurally between branches while producing identical entity state after deserialization. For example:
   
   - **Branch A**: Entity lives entirely in a base module repo (no delta)
   - **Branch B**: Entity is split across a base module repo and a delta module repo, where the delta overrides some properties but the compiled (merged) result is semantically identical
   
   This is compounded by the fact that Git file naming conventions and file-to-entity granularity have changed over time — one file in base may correspond to a differently named file in delta, or to multiple files, or vice versa.
   
   A file-level diff fundamentally cannot detect this equivalence — it operates below the deserialization boundary.

All three categories share the same root cause: **the diff operates on Git files instead of on deserialized entity state**. Files are a storage/transport concern; entity state is what matters. These false positives cascade into package creation — entities that aren't actually different get included in CM packages unnecessarily, adding noise and risk to the deployment pipeline.

---

## From Diff Fix to Pipeline Redesign

The starting requirement is narrow: fix diff elimination. But solving it properly uncovers a chain of dependencies that expands the scope at each step.

**The diff must be semantic.** Textual Git diffs can't distinguish identical entity state from different file representations — that's the root cause. So the diff must deserialize Git content into strongly typed objects and compare those instead.

**Semantic diff must be solution-level.** Entities span config blocks; a single entity's complete state can only be reconstructed through full solution compilation. A per-block diff cannot produce complete deserialized objects for comparison.

**Solution-level diff output is incompatible with the existing package pipeline.** The current pipeline is block-scoped, file-oriented, and DB-dependent. It cannot consume the output of a solution-level semantic diff (see below).

**Therefore: a new solution-level package model and import workflow are required.** The semantic diff alone doesn't solve diff elimination — the existing package pipeline can't consume its output. Both must be delivered together. This is not scope creep — it's a dependency chain.

### Why the Existing Pipeline Cannot Be Reused

The current package pipeline was designed around the Git file diff model:

1. **Git diff** → flat list of changed files (arbitrary subset, user-selected)
2. **`GetPublishedConfigEntities`** → re-reads each file from Git, deserializes independently, resolves parentage by **querying the TenantDB** (e.g., for a `DimensionTranslation`, it looks up the parent Dimension's DB ID by name). Produces a flat `List<PublishedConfigEntity>` where `ParentEntityId` is a DB record ID.
3. **Package builder** → takes the flat list, resolves dependencies, serializes into a block-scoped `PublishedModelPackage` (single `ModuleId`).

This pipeline has a critical property: it can process **any arbitrary subset of changed files** independently. Each file is deserialized and parentage-resolved in isolation via DB queries. This works because the parentage context comes from the live DB, not from the diff.

The semantic diff model is fundamentally incompatible:

- **Full solution compilation is required** before any comparison can happen. The `ComparisonNode` tree is built by comparing two complete `IComparisonContext` snapshots — there is no incremental mode.
- **Parentage is structural, not DB-resolved.** The `ComparisonNode` tree gets its hierarchy from the `CompareEntityTree` handler tree, not from TenantDB queries. This is cleaner (no DB dependency for the diff), but means the tree can only be produced from a full compilation.
- **The `GetPublishedConfigEntities` step becomes redundant.** It re-does work the semantic diff has already completed: Git content reading, deserialization, and entity identification. The `ComparisonNode` tree already carries deserialized source/target objects, entity GUIDs, change types, and the full parent-child hierarchy.
- **Entity granularity differs.** The compare engine sees finer-grained entities (translations, aliases as separate `ComparisonNode` children) than the current package model (which aggregates at the parent entity level). Some Git-level entities (position properties, computed fields like `DefaultPageName` in `WorkspaceGitAdapter`) are derived by GitSync adapters and don't exist in the package model at all.
- **Packages are block-scoped, the diff is solution-scoped.** `PublishedModelPackage` has a single `ModuleId`. The semantic diff produces one tree for the entire solution.

Adapting the semantic diff output to feed the existing block-scoped pipeline would require re-introducing the very problems the semantic diff eliminates: DB-dependent parentage resolution, per-file independent processing, and block-level scoping that fragments the solution-level view.

### New Solution-Level Package Model

Beyond the architectural incompatibility, the existing package pipeline has not stabilized despite sustained bug-fixing effort over multiple years (see [CM 2.0 Problem Landscape](../../c2-requirements/config-requirements/cm2-strategic-enhancements-pov.md)). The pipeline was built incrementally on top of CM 1.0 and each bug fix adds special-case logic without addressing the structural root causes. Incremental adaptation of this pipeline to consume the semantic diff would compound the problem: layering a new architectural model on top of an already fragile system.

The existing package workflow will not be adapted. Instead, a **new class of solution-level packages** will be built with a custom import workflow, natively consuming the `ComparisonNode` tree.

This new package model should:

- **Be solution-scoped, not block-scoped.** The package represents a set of entity changes across the entire solution. Config block attribution (via `ModuleId` on entities) is internal detail, not the organizing principle.
- **Use GUID-based identity and tree-based parentage.** No `ParentEntityId` (DB record ID). Parentage is expressed through the `ComparisonNode` tree structure. Entity identity is GUID-based, consistent with `ComparisonStrategy.EntityGuid`.
- **Carry deserialized entity payloads.** The `ComparisonNode` already holds source and target RPCModel objects. The package can embed these directly rather than re-reading from Git or DB.
- **Support entity selection from the tree.** Users select entities (subtrees) from the pre-compiled `ComparisonNode` tree, not files from a Git diff.
- **Include a custom import workflow.** Import operates on the solution-level package, dispatching CRUD operations based on `ComparisonNode` change types (`RpcType` → controller, `ChangeType` → POST/PUT/DELETE, `TargetObject` → payload).

---

## The Solution: Semantic Config Pipeline

Replace the Git-level text diff and block-scoped package pipeline with a five-phase approach:

### Phase 1: Deserialize → Strongly Typed Objects

For each branch, read Git content across the **entire solution** (solution block + all config blocks) and deserialize into strongly typed RPCModels — using the **same deserialization code path** as the production solution load (Compiler). This ensures the diff sees exactly what the platform would see after a load.

### Phase 2: Compare via the Diff Engine

Feed both branches' deserialized state into the existing compare engine (`CompareConfigWorkflow`). Entities are matched by GUID and compared property-by-property on the strongly typed objects — not on their JSON text representation. Only entities with actual semantic differences appear in the result.

### Phase 3: Entity Selection from the Comparison Tree

Users select entities (subtrees) from the pre-compiled `ComparisonNode` tree — not files from a Git diff. The tree provides full semantic context: entity names, change types, parent-child relationships, and data-impacting property flags.

### Phase 4: Solution-Level Package Creation

Selected entities are packaged into a solution-scoped package carrying deserialized entity payloads, GUID-based identity, and tree-based parentage. No DB record IDs, no block-level scoping.

### Phase 5: Import via CRUD Dispatch

Import operates on the solution-level package, dispatching CRUD operations based on `ComparisonNode` change types (`RpcType` → controller, `ChangeType` → POST/PUT/DELETE, `TargetObject` → payload).

### Foundational Shift: Solution-Level, Not Block-Level

All five phases operate at the **solution level** — the entire tenant's configuration across all config blocks. This is the only level at which:

- Entity trees can be fully deserialized with all cross-block relationships intact
- The result is meaningful to users, who see and manage the full tenant — not individual Git repos

The per-block boundary (current `moduleId` parameter) was only present because the old diff delegated to per-repo Git APIs. The new pipeline has no `moduleId` — it treats the full solution as a single unit.

### No TenantDB Dependency for Diff and Package Creation

The current pipeline requires a running TenantDB to produce a package — `GetPublishedConfigEntities` resolves parentage by querying the target tenant's DB for parent entity record IDs, and the package model uses these DB IDs for entity relationships.

The new pipeline eliminates this dependency for phases 1–4. Diff, entity selection, and package creation are pure Git-to-Git operations: both snapshots are deserialized from Git content, compared in memory, and packaged with GUID-based identity and tree-based parentage. No running tenant is needed.

Only phase 5 (import) requires a TenantDB — it dispatches CRUD operations to the target tenant, and Git updates flow through the existing GitSync adapters. This is inherent: writing changes to a tenant requires the tenant to exist.

### Tenant as a Version Resolution Shortcut

The primary use case specifies branches explicitly (e.g., "compare `release/2.5` against `main`"). But it should also be possible to say "use whatever this tenant currently has loaded" as one side of the comparison. The tenant resolves to specific Git versions — each config block has a loaded branch/tag — and the system deserializes from those Git versions as usual. It's still the same Git-to-Compiler path; the tenant just provides the version resolution instead of a uniform branch name.

---

## What Else This Architecture Solves

The scope expansion is significant — but the upside is proportional. The [CM 2.0 Problem Landscape](../../c2-requirements/config-requirements/cm2-strategic-enhancements-pov.md) identifies 15 known problems. The semantic config pipeline addresses 13 of them:

| #   | Problem                                                             | How This Architecture Addresses It                                                                                                                                                                                                                   |
| --- | ------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1   | **Diff Elimination Doesn't Always Work** (Critical)                 | **Directly solved.** Semantic diff compares deserialized entity state, not Git file text. Different serialization paths, platform versions, and file structures become invisible — the compare engine sees only the logical entity model.            |
| 2   | **No State Equivalence Guarantee Between Test and Prod** (Critical) | **Enabled.** Compare a loaded production tenant snapshot against the approved release tag snapshot. If the ComparisonNode tree is empty, states are equivalent.                                                                                      |
| 4   | **Destructive Changes Require Manual Identification** (High)        | **Directly solved.** Each ComparisonNode has `ChangeType` (Added/Modified/Removed) and the compare handlers define `GetDataImpactingProperties()` per entity type. Destructive changes are automatically detected — no manual classification needed. |
| 6   | **Package Creation and Import Performance** (High)                  | **Directly solved.** The current pipeline's performance problems stem from anti-patterns in create and import: re-reading files from Git, re-deserializing content already processed by the diff, and resolving parentage via DB queries. The new pipeline eliminates all of this — package creation consumes the already-compiled `ComparisonNode` tree, and import dispatches directly from it. |
| 7   | **Branch-to-Branch Diffs Are Not User-Friendly** (High)             | **Directly solved.** Semantic diff returns entity-level changes with typed objects, entity names, and change types — not raw JSON file diffs.                                                                                                        |
| 8   | **Package Import Does Not Respect Entity Dependencies** (High)      | **Directly solved.** The `EntityTree` defines import ordering based on entity dependency hierarchy. Import walks the tree in dependency order rather than treating entities as an unordered set.                                                       |
| 9   | **Child Entity Import Is Destructive Rather Than Differential** (High) | **Directly solved.** Each entity has its own `ComparisonNode` with an individual `ChangeType`. Import dispatches CRUD operations only for entities that actually changed — unchanged children are not touched.                                       |
| 10  | **Import Failures Can Be Silent** (High)                            | **Enabled.** Import dispatches discrete CRUD operations per entity, each with a clear entity identity (from the `ComparisonNode`) and expected outcome (from `ChangeType`). This makes per-entity success/failure tracking natural to implement.      |
| 11  | **No Conflict Detection** (Medium)                                  | **Enabled.** Before import, compare the package's source snapshot against the target's current state. If the target has diverged, the comparison reveals the conflicts at the entity level.                                                          |
| 12  | **Granularity Mismatch Between Promotion and Packaging** (Medium)   | **Directly solved.** The semantic diff uses the `CompareEntityTree` handler hierarchy as the authoritative definition of entity boundaries, aligning CM's entity concept with the rest of the Config 2.0 framework.                                  |
| 13  | **Insufficient Context for Selective Packaging** (Medium)           | **Enabled.** Instead of "these files changed," the system knows "these entities changed in these ways." Users select from a semantic entity tree, not a file list.                                                                                   |
| 14  | **APIs Not Automation-Friendly** (Medium)                           | **Directly solved.** The current pipeline requires the UI to orchestrate multiple sequential API calls (diff → file selection → entity building → package creation). The new pipeline's package creation consumes the `ComparisonNode` tree directly, eliminating the multi-call orchestration that makes the current API impossible to automate. |
| 15  | **Entity Renames Can't Be Supported** (Medium)                      | **Enabled.** GUID-based entity matching means a renamed entity (same GUID, different name) is detected as a modification rather than delete + add.                                                                                                   |

**Problems not directly addressed** (require separate solutions):

- **#3 GUID Lifecycle Inconsistency** — Root cause is in how GUIDs are generated during entity creation across branches and base-delta, which is a platform-level concern beyond the CM pipeline
- **#5 Package Imports Are Not Atomic** — Requires transactional CRUD infrastructure, orthogonal to diff

---

## Entity Scope

The entire solution — all config blocks for the tenant — must be deserialized and compared as a single unit. Entity types span all categories:

| Category          | Examples                                                                    |
| ----------------- | --------------------------------------------------------------------------- |
| **Core Model**    | Plans, MeasureGroups, Measures (+ Aliases, Translations, Properties, etc.)  |
| **Dimensions**    | Dimensions, Attributes, Hierarchies, Levels (+ Translations, Aliases, etc.) |
| **Relationships** | MemberRelationshipTypes, NodeAttributes, Properties                         |
| **Rules**         | RuleGroups, InverseRules, IbplRules                                         |
| **UI**            | Workspaces, Pages, Views, Widgets, ActionButtons, MassEditTemplates         |
| **Alerts**        | Alerts, Plays, PlayScenarios                                                |
| **Plugins**       | GlobalPlugins, TenantPlugins (+ Configured variants)                        |
| **Other**         | Locales, Modules, Picklists, LSSequences, Roles, ETLPackages                |

The solution block (itself a Git repo) must be included alongside all config blocks.

---

## Success Criteria

1. **Diff elimination**: After a CM package import, a subsequent semantic diff between the same branches must show zero changes for the imported entities
2. **No false positives**: Entities that are semantically identical must not appear in the diff, regardless of Git file differences
3. **No false negatives**: Entities that are semantically different must appear in the diff
4. **Performance**: The semantic diff must complete within acceptable time bounds for typical solution sizes
5. **Compatibility**: The result must be consumable by the new solution-level package workflow
6. **Coverage**: All entity types in the compare entity tree must be supported

---

## Risks

| Risk                                                                                             | Mitigation                                                                                                                                                                                                                                                      |
| ------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Performance: full solution deserialization for both branches is heavier than a Git diff API call | Parallelize source/target; cache branch snapshots by commit hash                                                                                                                                                                                                |
| Deserialization failures for malformed/legacy Git files                                          | Graceful error handling per entity; report partial results                                                                                                                                                                                                      |
| Compare engine does not cover all entity types                                                   | Audit against all Git entity types; add missing handlers                                                                                                                                                                                                        |
| Scope expansion: new package model + import workflow significantly increases effort              | The semantic diff and new pipeline are coupled — the diff alone doesn't solve diff elimination because the existing package pipeline can't consume it. Both must be delivered together. Manage scope by implementing incrementally but shipping as one release. |
| Migration: existing block-scoped packages must coexist during transition                         | Run old and new pipelines in parallel until the new workflow is validated end-to-end                                                                                                                                                                            |

---

*See also:*

- *[Analysis](analysis.md) — Codebase investigation, feasibility, and approach comparison*
- *[Architecture Notes](architecture.md) — Implementation-level detail*
- *[Future Opportunities](future-opportunities.md) — Platform-level extensions beyond CM 3.0*
- *[Evolution](evolution.md) — How the thinking evolved across sessions*
